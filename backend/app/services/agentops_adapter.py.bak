"""
AgentOps Adapter for Self-Hosted API

AgentOps self-hosted API를 직접 호출하여 실제 데이터를 조회하는 어댑터.
ClickHouse 기반 데이터를 AgentOps API v4를 통해 가져옴.
"""

import httpx
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import json
from fastapi import HTTPException


class AgentOpsAdapter:
    """
    AgentOps self-hosted API 클라이언트.
    
    AgentOps API v4 엔드포인트:
    - GET /v4/traces/list/{project_id}: 트레이스 목록
    - GET /v4/traces/detail/{trace_id}: 트레이스 상세
    - GET /v4/meterics/project/{project_id}: 프로젝트 메트릭
    
    Attributes:
        api_url: AgentOps API 기본 URL
        api_key: AgentOps API 키
        headers: HTTP 헤더 (Authorization 포함)
    """
    
    def __init__(
        self,
        api_url: str = "http://host.docker.internal:8003",
        email: str = "admin@agent-portal.local",
        password: str = "agentops-admin-password"
    ):
        self.api_url = api_url
        self.email = email
        self.password = password
        self.session_cookie = None
        self.cookie_name = "ao_session"  # AgentOps 기본 쿠키 이름
    
    async def _ensure_authenticated(self):
        """세션 쿠키가 없으면 로그인하여 얻습니다."""
        if self.session_cookie:
            return

        # AgentOps 로그인 API 호출
        login_url = f"{self.api_url}/auth/login"
        payload = {
            "email": self.email,
            "password": self.password
        }

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(login_url, json=payload)
                response.raise_for_status()

                # Set-Cookie 헤더에서 세션 쿠키 추출
                cookies = response.cookies
                if self.cookie_name in cookies:
                    self.session_cookie = cookies[self.cookie_name]
                    print(f"✅ AgentOps 로그인 성공: {self.email}")
                else:
                    print(f"⚠️  Warning: Session cookie '{self.cookie_name}' not found in response")
                    # 다른 가능한 쿠키 이름 확인
                    for cookie_name in cookies:
                        if "session" in cookie_name.lower() or "auth" in cookie_name.lower():
                            self.session_cookie = cookies[cookie_name]
                            self.cookie_name = cookie_name
                            print(f"✅ AgentOps 로그인 성공: {self.email} (cookie: {cookie_name})")
                            break

        except httpx.HTTPStatusError as e:
            print(f"❌ AgentOps 로그인 실패 ({e.response.status_code}): {e.response.text}")
            raise HTTPException(
                status_code=500,
                detail=f"Failed to authenticate with AgentOps: {e.response.text}"
            )
        except Exception as e:
            print(f"❌ AgentOps 로그인 에러: {str(e)}")
            raise HTTPException(
                status_code=500,
                detail=f"Failed to connect to AgentOps for authentication: {str(e)}"
            )
    
    def _get_auth_headers(self) -> Dict[str, str]:
        """API 호출에 필요한 인증 헤더를 반환합니다."""
        headers = {
            "Content-Type": "application/json"
        }
        if self.session_cookie:
            headers["Cookie"] = f"{self.cookie_name}={self.session_cookie}"
        return headers
    
    async def get_traces(
        self,
        project_id: str,
        start_time: datetime,
        end_time: datetime,
        search: Optional[str] = None,
        page: int = 1,
        size: int = 20
    ) -> Dict[str, Any]:
        """
        트레이스 목록 조회 (AgentOps API v4).
        
        Returns:
            {
                "traces": [...],
                "metrics": {...},
                "total": int,
                "limit": int,
                "offset": int
            }
        """
        try:
            offset = (page - 1) * size
            
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.api_url}/v4/traces/list/{project_id}",
                    headers=self.headers,
                    params={
                        "start_time": start_time.isoformat(),
                        "end_time": end_time.isoformat(),
                        "query": search,
                        "limit": size,
                        "offset": offset,
                        "order_by": "start_time",
                        "sort_order": "DESC"
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                # AgentOps 응답을 우리 형식으로 변환
                return {
                    "traces": [self._convert_trace_item(t) for t in data.get("traces", [])],
                    "metrics": data.get("metrics", {}),
                    "total": data.get("total", 0),
                    "limit": size,
                    "offset": offset
                }
        except httpx.HTTPStatusError as e:
            raise HTTPException(
                status_code=e.response.status_code,
                detail=f"AgentOps API error: {e.response.text}"
            )
        except httpx.TimeoutException:
            raise HTTPException(status_code=504, detail="AgentOps API timeout")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch traces: {str(e)}")
    
    def _convert_trace_item(self, trace: Dict[str, Any]) -> Dict[str, Any]:
        """AgentOps 트레이스 아이템을 우리 형식으로 변환"""
        return {
            "trace_id": trace.get("trace_id"),
            "project_id": trace.get("project_id", "default-project"),
            "service_name": trace.get("root_service_name"),
            "root_span_name": trace.get("root_span_name"),
            "start_time": trace.get("start_time"),
            "end_time": trace.get("end_time"),
            "duration": trace.get("duration"),
            "span_count": trace.get("span_count", 0),
            "error_count": trace.get("error_count", 0),
            "tags": trace.get("tags", []),
            "total_cost": trace.get("total_cost", 0.0),
            "status": "error" if trace.get("error_count", 0) > 0 else "success"
        }
    
    async def get_trace_detail(self, trace_id: str) -> Dict[str, Any]:
        """
        트레이스 상세 조회 (AgentOps API v4).
        
        Returns:
            {
                "trace_id": str,
                "project_id": str,
                "spans": [...]
            }
        """
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.api_url}/v4/traces/detail/{trace_id}",
                    headers=self.headers
                )
                response.raise_for_status()
                data = response.json()
                
                return {
                    "trace_id": data.get("trace_id"),
                    "project_id": data.get("project_id", "default-project"),
                    "spans": [self._convert_span_item(s) for s in data.get("spans", [])]
                }
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                return None
            raise HTTPException(
                status_code=e.response.status_code,
                detail=f"AgentOps API error: {e.response.text}"
            )
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch trace detail: {str(e)}")
    
    def _convert_span_item(self, span: Dict[str, Any]) -> Dict[str, Any]:
        """AgentOps 스팬 아이템을 우리 형식으로 변환"""
        return {
            "span_id": span.get("span_id"),
            "parent_span_id": span.get("parent_span_id"),
            "span_name": span.get("span_name"),
            "span_kind": span.get("span_kind"),
            "service_name": span.get("service_name"),
            "timestamp": span.get("start_time"),
            "duration": span.get("duration"),
            "status_code": span.get("status_code"),
            "status_message": span.get("status_message"),
            "span_attributes": span.get("span_attributes", {}),
            "resource_attributes": span.get("resource_attributes", {})
        }
    
    async def get_metrics(
        self,
        project_id: str,
        start_time: datetime,
        end_time: datetime
    ) -> Dict[str, Any]:
        """
        메트릭 집계 조회.
        
        트레이스 목록에서 집계된 메트릭을 가져옴.
        """
        try:
            # 트레이스 목록에 이미 집계된 메트릭 포함됨
            traces_result = await self.get_traces(
                project_id=project_id,
                start_time=start_time,
                end_time=end_time,
                page=1,
                size=1  # 메트릭만 필요하므로 최소한만 조회
            )
            
            metrics = traces_result.get("metrics", {})
            
            # 기본값 설정
            return {
                "trace_count": traces_result.get("total", 0),
                "span_count": metrics.get("span_count", 0),
                "error_count": metrics.get("error_count", 0),
                "total_cost": metrics.get("total_cost", 0.0),
                "prompt_tokens": metrics.get("prompt_tokens", 0),
                "completion_tokens": metrics.get("completion_tokens", 0),
                "cache_read_input_tokens": metrics.get("cache_read_input_tokens", 0),
                "reasoning_tokens": metrics.get("reasoning_tokens", 0),
                "avg_duration": metrics.get("avg_duration", 0),
                "p50_duration": metrics.get("p50_duration", 0),
                "p95_duration": metrics.get("p95_duration", 0),
                "p99_duration": metrics.get("p99_duration", 0)
            }
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch metrics: {str(e)}")
    
    async def get_session_replay(self, trace_id: str) -> Dict[str, Any]:
        """
        세션 리플레이 데이터 생성.
        스팬을 시간순 이벤트로 변환.
        """
        trace_detail = await self.get_trace_detail(trace_id)
        if not trace_detail:
            return None
        
        spans = trace_detail.get('spans', [])
        
        # 스팬을 시간순으로 정렬
        sorted_spans = sorted(spans, key=lambda s: s['timestamp'])
        
        # 이벤트로 변환
        events = []
        start_time = None
        
        for span in sorted_spans:
            timestamp = datetime.fromisoformat(span['timestamp'].replace('Z', '+00:00'))
            if start_time is None:
                start_time = timestamp
            
            relative_time = int((timestamp - start_time).total_seconds() * 1000)
            
            # 이벤트 타입 추론
            event_type = self._infer_event_type(span)
            
            events.append({
                'timestamp': timestamp.isoformat(),
                'relative_time': relative_time,
                'type': event_type,
                'span_id': span['span_id'],
                'span_name': span['span_name'],
                'data': self._extract_event_data(span, event_type)
            })
        
        total_duration = int((datetime.fromisoformat(sorted_spans[-1]['timestamp'].replace('Z', '+00:00')) - start_time).total_seconds() * 1000) if sorted_spans else 0
        
        return {
            'trace_id': trace_id,
            'events': events,
            'timeline': [e['relative_time'] for e in events],
            'total_duration': total_duration,
            'start_time': int(start_time.timestamp() * 1000) if start_time else 0
        }
    
    def _infer_event_type(self, span: Dict[str, Any]) -> str:
        """스팬에서 이벤트 타입 추론"""
        attrs = span.get('span_attributes', {})
        
        if 'gen_ai.usage.total_cost' in attrs or 'llm' in span.get('span_name', '').lower():
            return 'llm_call'
        elif 'tool_name' in attrs:
            return 'tool_use'
        elif span.get('status_code') == 'ERROR':
            return 'error'
        elif 'decision' in attrs:
            return 'decision'
        else:
            return 'span_start'
    
    def _extract_event_data(self, span: Dict[str, Any], event_type: str) -> Dict[str, Any]:
        """이벤트 타입별 데이터 추출"""
        attrs = span.get('span_attributes', {})
        
        if event_type == 'llm_call':
            return {
                'model': attrs.get('gen_ai.request.model', 'unknown'),
                'prompt': attrs.get('gen_ai.prompt', ''),
                'response': attrs.get('gen_ai.completion', ''),
                'prompt_tokens': attrs.get('gen_ai.usage.prompt_tokens', 0),
                'completion_tokens': attrs.get('gen_ai.usage.completion_tokens', 0),
                'total_tokens': attrs.get('gen_ai.usage.total_tokens', 0),
                'cost': attrs.get('gen_ai.usage.total_cost', 0.0),
                'latency': span.get('duration', 0)
            }
        elif event_type == 'tool_use':
            return {
                'tool_name': attrs.get('tool_name', 'unknown'),
                'input': attrs.get('input', {}),
                'output': attrs.get('output', {}),
                'duration': span.get('duration', 0),
                'status': 'success' if span.get('status_code') != 'ERROR' else 'error'
            }
        elif event_type == 'error':
            return {
                'error_type': attrs.get('error_type', 'UnknownError'),
                'error_message': span.get('status_message', 'Unknown error'),
                'stack_trace': attrs.get('stack_trace'),
                'span_id': span['span_id']
            }
        else:
            return {
                'span_id': span['span_id'],
                'span_name': span['span_name'],
                'status': span.get('status_code', 'UNSET')
            }
    
    async def get_trace_timeline(self, trace_id: str) -> Dict[str, Any]:
        """
        트레이스 타임라인 생성 (계층 구조 포함).
        """
        trace_detail = await self.get_trace_detail(trace_id)
        if not trace_detail:
            return None
        
        spans = trace_detail.get('spans', [])
        
        # 스팬을 트리 구조로 변환
        span_nodes = self._build_span_tree(spans)
        
        # 타임라인 정보 계산
        start_times = [datetime.fromisoformat(s['timestamp'].replace('Z', '+00:00')) for s in spans]
        start_time = min(start_times) if start_times else datetime.now()
        end_times = [datetime.fromisoformat(s['timestamp'].replace('Z', '+00:00')) + timedelta(microseconds=s['duration']/1000) for s in spans]
        end_time = max(end_times) if end_times else start_time
        total_duration = int((end_time - start_time).total_seconds() * 1000)
        
        # 크리티컬 패스 계산 (가장 긴 경로)
        critical_path = self._calculate_critical_path(span_nodes)
        
        return {
            'trace_id': trace_id,
            'spans': span_nodes,
            'total_duration': total_duration,
            'critical_path': critical_path,
            'start_time': int(start_time.timestamp() * 1000),
            'end_time': int(end_time.timestamp() * 1000)
        }
    
    def _build_span_tree(self, spans: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """스팬을 계층 구조로 변환"""
        span_map = {s['span_id']: s for s in spans}
        roots = []
        
        for span in spans:
            timestamp = datetime.fromisoformat(span['timestamp'].replace('Z', '+00:00'))
            span['start_time_ms'] = int(timestamp.timestamp() * 1000)
            span['children'] = []
            
            parent_id = span.get('parent_span_id')
            if parent_id and parent_id in span_map:
                span_map[parent_id].setdefault('children', []).append(span)
            else:
                roots.append(span)
        
        return roots
    
    def _calculate_critical_path(self, span_nodes: List[Dict[str, Any]]) -> List[str]:
        """크리티컬 패스 계산 (가장 긴 경로)"""
        def find_longest_path(node):
            if not node.get('children'):
                return [node['span_id']], node['duration']
            
            longest_path = []
            max_duration = 0
            
            for child in node['children']:
                path, duration = find_longest_path(child)
                if duration > max_duration:
                    max_duration = duration
                    longest_path = path
            
            return [node['span_id']] + longest_path, node['duration'] + max_duration
        
        critical_path = []
        max_duration = 0
        
        for root in span_nodes:
            path, duration = find_longest_path(root)
            if duration > max_duration:
                max_duration = duration
                critical_path = path
        
        # 크리티컬 패스 마킹
        def mark_critical(node):
            if node['span_id'] in critical_path:
                node['is_critical_path'] = True
            for child in node.get('children', []):
                mark_critical(child)
        
        for root in span_nodes:
            mark_critical(root)
        
        return critical_path
    
    async def get_cost_trend(
        self,
        project_id: str,
        start_time: datetime,
        end_time: datetime,
        interval: str = 'day'
    ) -> List[Dict[str, Any]]:
        """
        비용 추이 데이터 조회.
        
        AgentOps API에서 트레이스 목록을 가져와 집계.
        """
        try:
            # 전체 트레이스 조회 (페이지네이션 없이)
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.api_url}/v4/traces/list/{project_id}",
                    headers=self.headers,
                    params={
                        "start_time": start_time.isoformat(),
                        "end_time": end_time.isoformat(),
                        "limit": 1000,  # 충분히 큰 값
                        "offset": 0,
                        "order_by": "start_time",
                        "sort_order": "ASC"
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                traces = data.get("traces", [])
                
                # 날짜별 집계
                cost_by_date = {}
                for trace in traces:
                    if not trace.get('start_time'):
                        continue
                    
                    trace_date = datetime.fromisoformat(trace['start_time'].replace('Z', '+00:00'))
                    
                    if interval == 'hour':
                        key = trace_date.strftime('%Y-%m-%d %H:00:00')
                    elif interval == 'week':
                        key = trace_date.strftime('%Y-%U')
                    else:  # day
                        key = trace_date.strftime('%Y-%m-%d')
                    
                    cost_by_date[key] = cost_by_date.get(key, 0) + trace.get('total_cost', 0)
                
                return [
                    {'timestamp': date, 'cost': float(cost)}
                    for date, cost in sorted(cost_by_date.items())
                ]
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch cost trend: {str(e)}")
    
    async def get_token_usage(
        self,
        project_id: str,
        start_time: datetime,
        end_time: datetime,
        interval: str = 'day'
    ) -> List[Dict[str, Any]]:
        """
        토큰 사용량 추이 조회.
        
        트레이스 목록에서 집계.
        """
        try:
            # 메트릭에서 토큰 정보 가져오기 (실제로는 트레이스별 집계 필요)
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.api_url}/v4/traces/list/{project_id}",
                    headers=self.headers,
                    params={
                        "start_time": start_time.isoformat(),
                        "end_time": end_time.isoformat(),
                        "limit": 1000,
                        "offset": 0,
                        "order_by": "start_time",
                        "sort_order": "ASC"
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                traces = data.get("traces", [])
                
                # 날짜별 집계
                tokens_by_date = {}
                for trace in traces:
                    if not trace.get('start_time'):
                        continue
                    
                    trace_date = datetime.fromisoformat(trace['start_time'].replace('Z', '+00:00'))
                    
                    if interval == 'hour':
                        key = trace_date.strftime('%Y-%m-%d %H:00:00')
                    elif interval == 'week':
                        key = trace_date.strftime('%Y-%U')
                    else:  # day
                        key = trace_date.strftime('%Y-%m-%d')
                    
                    if key not in tokens_by_date:
                        tokens_by_date[key] = {
                            'prompt_tokens': 0,
                            'completion_tokens': 0,
                            'cache_hits': 0
                        }
                    
                    # 메트릭에서 토큰 정보 추출 (AgentOps v4는 trace 레벨에 토큰 정보 없음)
                    # 임시로 0으로 설정 (실제로는 span_attributes에서 집계 필요)
                    tokens_by_date[key]['prompt_tokens'] += 0
                    tokens_by_date[key]['completion_tokens'] += 0
                    tokens_by_date[key]['cache_hits'] += 0
                
                return [
                    {
                        'timestamp': date,
                        'prompt_tokens': tokens['prompt_tokens'],
                        'completion_tokens': tokens['completion_tokens'],
                        'cache_hits': tokens['cache_hits']
                    }
                    for date, tokens in sorted(tokens_by_date.items())
                ]
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch token usage: {str(e)}")
    
    async def get_performance_metrics(
        self,
        project_id: str,
        start_time: datetime,
        end_time: datetime
    ) -> List[Dict[str, Any]]:
        """
        성능 메트릭 조회 (레이턴시 분포).
        """
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.api_url}/v4/traces/list/{project_id}",
                    headers=self.headers,
                    params={
                        "start_time": start_time.isoformat(),
                        "end_time": end_time.isoformat(),
                        "limit": 1000,
                        "offset": 0,
                        "order_by": "start_time",
                        "sort_order": "DESC"
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                traces = data.get("traces", [])
                
                return [
                    {
                        'timestamp': trace.get('start_time'),
                        'duration': int(trace.get('duration', 0) / 1000000),  # ns to ms
                        'status': 'error' if trace.get('error_count', 0) > 0 else 'success'
                    }
                    for trace in traces
                    if trace.get('start_time')
                ]
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch performance metrics: {str(e)}")
    
    async def get_agent_flow_graph(
        self,
        project_id: str,
        trace_id: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """
        에이전트 플로우 그래프 조회.
        
        스팬 관계를 노드-엣지 그래프로 변환.
        """
        # 단일 트레이스의 경우
        if trace_id:
            trace_detail = await self.get_trace_detail(trace_id)
            if not trace_detail:
                return {"nodes": [], "edges": []}
            
            spans = trace_detail.get('spans', [])
        else:
            # 기간 내 트레이스 샘플링
            traces_result = await self.get_traces(
                project_id=project_id,
                start_time=start_time or (datetime.now() - timedelta(days=1)),
                end_time=end_time or datetime.now(),
                page=1,
                size=10  # 샘플
            )
            
            # 첫 번째 트레이스만 사용
            if not traces_result['traces']:
                return {"nodes": [], "edges": []}
            
            first_trace = traces_result['traces'][0]
            trace_detail = await self.get_trace_detail(first_trace['trace_id'])
            if not trace_detail:
                return {"nodes": [], "edges": []}
            
            spans = trace_detail.get('spans', [])
        
        # 노드 및 엣지 생성
        nodes = []
        edges = []
        
        for span in spans:
            nodes.append({
                'id': span['span_id'],
                'label': span['span_name'],
                'type': span.get('span_kind', 'INTERNAL'),
                'service': span.get('service_name', 'unknown'),
                'duration': span.get('duration', 0)
            })
            
            if span.get('parent_span_id'):
                edges.append({
                    'source': span['parent_span_id'],
                    'target': span['span_id'],
                    'label': f"{int(span.get('duration', 0) / 1000000)}ms"
                })
        
        return {
            'nodes': nodes,
            'edges': edges
        }
    
    async def get_agent_usage_stats(
        self,
        project_id: str,
        start_time: datetime,
        end_time: datetime
    ) -> List[Dict[str, Any]]:
        """
        에이전트별 사용량 통계 조회.
        
        service_name 별로 집계.
        """
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.api_url}/v4/traces/list/{project_id}",
                    headers=self.headers,
                    params={
                        "start_time": start_time.isoformat(),
                        "end_time": end_time.isoformat(),
                        "limit": 1000,
                        "offset": 0
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                traces = data.get("traces", [])
                
                # service_name별 집계
                stats_by_service = {}
                for trace in traces:
                    service = trace.get('root_service_name', 'unknown')
                    
                    if service not in stats_by_service:
                        stats_by_service[service] = {
                            'agent_name': service,
                            'total_tokens': 0,
                            'total_cost': 0.0,
                            'event_count': 0,
                            'total_latency': 0,
                            'error_count': 0
                        }
                    
                    stats_by_service[service]['total_tokens'] += 0  # 토큰 정보 없음
                    stats_by_service[service]['total_cost'] += trace.get('total_cost', 0)
                    stats_by_service[service]['event_count'] += trace.get('span_count', 0)
                    stats_by_service[service]['total_latency'] += trace.get('duration', 0)
                    stats_by_service[service]['error_count'] += trace.get('error_count', 0)
                
                # 평균 레이턴시 및 성공률 계산
                result = []
                for service, stats in stats_by_service.items():
                    event_count = stats['event_count']
                    total_events = event_count
                    success_events = total_events - stats['error_count']
                    
                    result.append({
                        'agent_name': stats['agent_name'],
                        'total_tokens': stats['total_tokens'],
                        'total_cost': float(stats['total_cost']),
                        'event_count': event_count,
                        'avg_latency': float(stats['total_latency'] / event_count) if event_count > 0 else 0.0,
                        'error_count': stats['error_count'],
                        'success_rate': float(success_events / total_events * 100) if total_events > 0 else 100.0
                    })
                
                return result
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to fetch agent usage stats: {str(e)}")


# Singleton 인스턴스
agentops_adapter = AgentOpsAdapter()
