---
name: backend-api
description: Backend API 개발 규칙
globs: backend/**/*.py, webui/backend/**/*.py
alwaysApply: false
version: 2.0
lastUpdated: 2025-11-14
---

# Backend API Development Rules

Agent Portal의 Backend API 개발 시 반드시 따라야 하는 규칙입니다.

## Overview

이 문서는 FastAPI BFF와 WebUI Backend (Open-WebUI 내장)의 개발 패턴을 정의합니다. Singleton 서비스 레이어, 에러 핸들링, Observability 통합, PYTHONPATH 관리 등 프로덕션급 API 개발 규칙을 포함합니다.

## Examples

### Example 1: 서비스 레이어 패턴 (Singleton)

**패턴**:
```python
# backend/app/services/news_service.py
from typing import Dict, Any, List
import httpx
from pathlib import Path
import json
from fastapi import HTTPException

class NewsService:
    """뉴스 데이터를 관리하는 서비스 클래스.
    
    Attributes:
        data_path: 뉴스 데이터 디렉토리 경로
    """
    
    def __init__(self, data_path: str):
        self.data_path = Path(data_path)
    
    async def get_articles(
        self, 
        offset: int = 0, 
        limit: int = 20
    ) -> Dict[str, Any]:
        """뉴스 기사 목록 조회.
        
        Args:
            offset: 시작 인덱스
            limit: 조회할 기사 수
            
        Returns:
            기사 목록 및 페이지네이션 정보
            
        Raises:
            HTTPException: 파일 읽기 실패 시
        """
        try:
            today = datetime.now().strftime("%Y%m%d")
            index_file = self.data_path / today / "articles_index.json"
            
            with open(index_file, 'r', encoding='utf-8') as f:
                all_articles = json.load(f)
            
            # 중요도순 정렬
            sorted_articles = sorted(
                all_articles,
                key=lambda x: x.get('importance_score', 0),
                reverse=True
            )
            
            # 페이지네이션
            total = len(sorted_articles)
            articles = sorted_articles[offset:offset + limit]
            
            return {
                "articles": articles,
                "total": total,
                "offset": offset,
                "limit": limit,
                "has_more": (offset + limit) < total
            }
        except FileNotFoundError:
            raise HTTPException(
                status_code=404,
                detail=f"No articles found for date {today}"
            )
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Failed to read articles: {str(e)}"
            )

# Singleton 인스턴스
from app.config import settings
news_service = NewsService(settings.get_news_data_path())
```

**핵심 포인트**:
- Type hints 필수
- Docstring (Google 스타일)
- 에러 핸들링 (try/except)
- Singleton 패턴

### Example 2: 에러 핸들링 및 타임아웃

**Before** (잘못된 패턴):
```python
# ❌ 타임아웃 미설정, 에러 핸들링 누락
async def call_external_api():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/data")
        return response.json()
```

**After** (권장 패턴):
```python
# ✅ 타임아웃 30초, 에러 핸들링
async def call_external_api() -> Dict[str, Any]:
    """외부 API 호출.
    
    Returns:
        API 응답 데이터
        
    Raises:
        HTTPException: API 호출 실패 시
    """
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get("https://api.example.com/data")
            response.raise_for_status()
            return response.json()
    except httpx.TimeoutException:
        raise HTTPException(
            status_code=504,
            detail="External API timeout"
        )
    except httpx.HTTPStatusError as e:
        raise HTTPException(
            status_code=e.response.status_code,
            detail=f"External API error: {e.response.text}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Unexpected error: {str(e)}"
        )
```

**학습**: 외부 호출 시 타임아웃 30초 설정 필수, 에러 핸들링 3단계 (Timeout, HTTPStatus, General)

### Example 3: PYTHONPATH 설정 (WebUI Backend)

**문제 상황**:
```bash
# ❌ PYTHONPATH 없이 실행
uvicorn open_webui.main:app --reload
# ModuleNotFoundError: No module named 'open_webui'
```

**해결**:
```bash
# ✅ PYTHONPATH 명시
cd webui/backend
PYTHONPATH=. uvicorn open_webui.main:app --reload
```

**Dockerfile 설정**:
```dockerfile
# webui/Dockerfile.dev
ENV PYTHONPATH=/app/backend:$PYTHONPATH
```

**학습**: webui/backend 개발 시 PYTHONPATH 설정 필수 (Dockerfile.dev line 29, dev-start.sh line 27)

## 코딩 표준

### Python 스타일

- **PEP 8** 준수
- **Type hints** 필수
- **Docstring** 사용 (Google 스타일)
- **비동기 메서드** 사용 (`async def`)

### 서비스 레이어 패턴 (ALWAYS)

**Singleton 패턴** (모듈 레벨 인스턴스):
```python
# backend/app/services/example_service.py
from typing import Optional, Dict, Any
import httpx

class ExampleService:
    """External API 호출을 담당하는 서비스 클래스.
    
    Attributes:
        base_url: 외부 API의 기본 URL
    """
    
    def __init__(self):
        self.base_url = "http://example-service:8080"
    
    async def get_data(self, id: str) -> Dict[str, Any]:
        """특정 ID의 데이터를 조회.
        
        Args:
            id: 조회할 데이터의 ID
            
        Returns:
            데이터 딕셔너리
            
        Raises:
            HTTPException: API 호출 실패 시
        """
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(f"{self.base_url}/data/{id}")
            response.raise_for_status()
            return response.json()

# Singleton 인스턴스
example_service = ExampleService()
```

### 에러 핸들링 (ALWAYS)

**외부 호출 시 타임아웃 설정** (기본 30초):
```python
from fastapi import HTTPException
import httpx

async def call_external_api(endpoint: str) -> Dict[str, Any]:
    """외부 API 호출.
    
    Args:
        endpoint: API 엔드포인트 경로
        
    Returns:
        API 응답 데이터
        
    Raises:
        HTTPException: API 호출 실패 시
    """
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(f"https://api.example.com/{endpoint}")
            response.raise_for_status()
            return response.json()
    except httpx.TimeoutException:
        raise HTTPException(
            status_code=504,
            detail=f"External API timeout: {endpoint}"
        )
    except httpx.HTTPStatusError as e:
        raise HTTPException(
            status_code=e.response.status_code,
            detail=f"External API error: {e.response.text}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Unexpected error: {str(e)}"
        )
```

### 선택적 Import 패턴 (권장)

**의존성 미설치 시 Graceful Degradation**:
```python
# backend/app/services/langfuse_service.py
try:
    from langfuse import Langfuse
    LANGFUSE_AVAILABLE = True
except ImportError:
    LANGFUSE_AVAILABLE = False
    Langfuse = None

class LangfuseService:
    def __init__(self):
        if LANGFUSE_AVAILABLE:
            self.client = Langfuse()
        else:
            self.client = None
    
    def create_trace(self, name: str):
        """트레이스 생성 (Langfuse 사용 가능 시).
        
        Args:
            name: 트레이스 이름
            
        Returns:
            트레이스 객체 또는 None
        """
        if self.client is not None:
            return self.client.trace(name=name)
        return None  # Graceful degradation

langfuse_service = LangfuseService()
```

## FastAPI 라우터 패턴

### 라우터 생성

```python
# backend/app/routes/example.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Optional

# 라우터 인스턴스 생성
router = APIRouter(
    prefix="/example",
    tags=["example"]
)

# Request/Response 모델 정의
class ExampleRequest(BaseModel):
    """요청 모델.
    
    Attributes:
        field: 필드 설명
    """
    field: str

class ExampleResponse(BaseModel):
    """응답 모델.
    
    Attributes:
        result: 결과 설명
    """
    result: str

# 엔드포인트 정의
@router.post("/", response_model=ExampleResponse)
async def create_example(request: ExampleRequest) -> ExampleResponse:
    """Example 생성.
    
    Args:
        request: Example 요청 데이터
        
    Returns:
        생성된 Example 응답
        
    Raises:
        HTTPException: 생성 실패 시
    """
    # 비즈니스 로직
    result = await process_example(request.field)
    return ExampleResponse(result=result)
```

### 라우터 등록

```python
# backend/app/main.py
from fastapi import FastAPI
from app.routes import example

app = FastAPI(
    title="Agent Portal API",
    description="Backend for Frontend API",
    version="1.0.0"
)

# 라우터 등록
app.include_router(example.router)
```

## Pydantic 모델 패턴

### Request 모델

```python
from pydantic import BaseModel, Field, validator
from typing import Optional

class CreateUserRequest(BaseModel):
    """사용자 생성 요청.
    
    Attributes:
        username: 사용자 이름 (3-50자)
        email: 이메일 주소
        role: 사용자 역할 (선택, 기본값: user)
    """
    username: str = Field(..., min_length=3, max_length=50, description="사용자 이름")
    email: str = Field(..., description="이메일 주소")
    role: Optional[str] = Field("user", description="사용자 역할")
    
    @validator('email')
    def email_must_be_valid(cls, v):
        """이메일 주소 검증."""
        if '@' not in v:
            raise ValueError('invalid email address')
        return v.lower()
```

### Response 모델

```python
from pydantic import BaseModel
from typing import List
from datetime import datetime

class UserResponse(BaseModel):
    """사용자 응답.
    
    Attributes:
        id: 사용자 ID
        username: 사용자 이름
        email: 이메일 주소
        created_at: 생성 일시
    """
    id: str
    username: str
    email: str
    created_at: datetime
    
    class Config:
        """Pydantic 설정."""
        orm_mode = True  # ORM 모델과 호환
```

## Observability 통합

### Langfuse 트레이싱

```python
from app.services.langfuse_service import langfuse_service

@router.post("/chat")
async def chat(request: ChatRequest) -> ChatResponse:
    """채팅 API.
    
    Args:
        request: 채팅 요청
        
    Returns:
        채팅 응답
    """
    # 트레이스 생성
    trace = langfuse_service.create_trace(name="chat_api")
    
    try:
        # 스팬 생성
        span = trace.span(name="llm_call") if trace else None
        
        # LLM 호출
        result = await litellm_service.chat_completion(
            model=request.model,
            messages=request.messages
        )
        
        # 스팬 종료
        if span:
            span.end(output={"result": result})
        
        # 트레이스 종료
        if trace:
            trace.end()
        
        return ChatResponse(result=result)
    except Exception as e:
        # 에러 기록
        if trace:
            trace.end(status="error", output={"error": str(e)})
        raise
```

## 미들웨어 패턴

### RBAC 미들웨어 (TODO)

```python
# backend/app/middleware/rbac.py
from fastapi import Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware

class RBACMiddleware(BaseHTTPMiddleware):
    """RBAC (Role-Based Access Control) 미들웨어."""
    
    async def dispatch(self, request: Request, call_next):
        """요청 처리.
        
        Args:
            request: HTTP 요청
            call_next: 다음 미들웨어/핸들러
            
        Returns:
            HTTP 응답
            
        Raises:
            HTTPException: 권한 없음 시
        """
        # 사용자 인증 확인
        user = await get_current_user(request)
        
        # 관리자 전용 경로 확인
        if request.url.path.startswith("/admin"):
            if user.role != "admin":
                raise HTTPException(status_code=403, detail="Admin access required")
        
        response = await call_next(request)
        return response
```

## 리버스 프록시 패턴

### Perplexica/Open-Notebook 프록시

```python
# backend/app/routes/proxy.py
from fastapi import APIRouter, Request, Response
import httpx

router = APIRouter(prefix="/proxy", tags=["proxy"])

@router.api_route("/perplexica/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def proxy_perplexica(path: str, request: Request) -> Response:
    """Perplexica 리버스 프록시.
    
    Args:
        path: Perplexica API 경로
        request: FastAPI 요청
        
    Returns:
        Perplexica 응답
    """
    # 헤더 변환
    headers = dict(request.headers)
    headers.pop("host", None)  # Host 헤더 제거
    
    # Perplexica API 호출
    async with httpx.AsyncClient(timeout=30.0) as client:
        response = await client.request(
            method=request.method,
            url=f"http://perplexica:5173/{path}",
            headers=headers,
            content=await request.body()
        )
    
    # 헤더 정규화 (iframe 허용)
    response_headers = dict(response.headers)
    response_headers.pop("x-frame-options", None)
    response_headers["content-security-policy"] = "frame-ancestors 'self'"
    
    return Response(
        content=response.content,
        status_code=response.status_code,
        headers=response_headers
    )
```

## 테스트 및 검증

### 작업 완료 후 반드시 확인

- [ ] OpenAPI 문서 확인 (`http://localhost:8000/docs`)
- [ ] API 엔드포인트 직접 호출 테스트 (curl/Postman)
- [ ] 컨테이너 로그 확인 (`docker-compose logs backend`)
- [ ] 타임아웃 및 에러 핸들링 테스트
- [ ] Type hints 및 Docstring 확인

### 컨테이너 재빌드

**코드 변경 시**:
```bash
# 캐시 없이 재빌드
docker-compose build --no-cache backend
docker-compose restart backend

# 또는 개발 환경에서 볼륨 마운트 사용
# docker-compose.yml:
#   volumes:
#     - ./backend/app:/app/app:ro
```

## 학습 내용 기록

### 작업 완료 후

```bash
# API 패턴 학습 내용 기록
./scripts/record-learning.sh "API" "외부 호출 시 타임아웃 30초 설정 필수"

# 또는 수동으로 기록
echo "## $(date +%Y-%m-%d): 외부 API 호출 패턴

**요청**: LiteLLM API 호출 시 타임아웃 설정
**적용**: httpx.AsyncClient(timeout=30.0)
**피드백**: ✅ 잘 잡았어 (안정성 향상)
**재사용**: 모든 외부 호출에 타임아웃 설정
" >> .cursor/learnings/api-patterns.md
```

## 금지 사항

### ❌ 절대 하지 말 것

1. **기존 패턴 무시**:
   - ❌ 비슷한 API인데 새로운 서비스 레이어 패턴 사용
   - ✅ `backend/app/services/` 기존 패턴 재사용

2. **에러 핸들링 누락**:
   - ❌ 외부 호출 시 try/except 생략
   - ✅ 모든 외부 호출에 에러 핸들링 적용

3. **타임아웃 미설정**:
   - ❌ `httpx.AsyncClient()` (기본 타임아웃 5초)
   - ✅ `httpx.AsyncClient(timeout=30.0)` (명시적 타임아웃)

4. **Type hints 누락**:
   - ❌ `def get_data(id): ...`
   - ✅ `async def get_data(id: str) -> Dict[str, Any]: ...`

5. **동기 메서드 사용**:
   - ❌ `def get_data(): ...`
   - ✅ `async def get_data(): ...`

## WebUI Backend 개발 규칙 (CRITICAL)

Agent Portal은 두 개의 백엔드 시스템을 운영합니다:
1. **webui/backend**: Open-WebUI 내장 백엔드 (FastAPI + SQLAlchemy)
2. **backend/**: FastAPI BFF (Backend for Frontend)

### WebUI Backend 구조

**디렉토리 구조**:
```
webui/backend/
├── open_webui/          # 메인 Python 모듈
│   ├── main.py         # FastAPI 앱 진입점
│   ├── routers/        # API 라우터 (OpenAI, Ollama, Chat 등)
│   ├── models/         # SQLAlchemy 모델
│   ├── utils/          # 유틸리티 함수
│   └── retrieval/      # RAG 및 벡터 DB
├── requirements.txt    # Python 의존성
├── start.sh           # 프로덕션 시작 스크립트
└── dev.sh             # (사용되지 않음)
```

### PYTHONPATH 설정 (ALWAYS)

**규칙**: 모든 Python 서비스는 PYTHONPATH를 명시적으로 설정해야 합니다.

**개발 환경** (Docker Compose):
```dockerfile
# webui/Dockerfile.dev
ENV PYTHONPATH=/app/backend:$PYTHONPATH
```

**스크립트 실행**:
```bash
# webui/dev-start.sh
cd backend
PYTHONPATH=. uvicorn open_webui.main:app --host 0.0.0.0 --port 8080 --reload &
```

**프로덕션**:
```bash
# webui/start.sh
cd backend
export PYTHONPATH=.
uvicorn open_webui.main:app --host 0.0.0.0 --port 8080
```

### 개발 서버 실행 (docker-compose.dev.yml)

**포트 매핑**:
- `5173:3001`: Vite 프론트엔드 개발 서버 (핫 리로드)
- `8080:3000`: Open-WebUI 백엔드 API

**볼륨 마운트**:
```yaml
volumes:
  - ./webui:/app                          # 소스 코드 실시간 마운트
  - webui_node_modules:/app/node_modules  # node_modules 분리
  - webui_backend_data:/app/backend/data  # DB 데이터 영구 저장
```

**환경 변수**:
```yaml
environment:
  - DEV_MODE=true
  - AUTO_RELOAD=true
  - DEBUG=true
```

**실행 명령**:
```bash
# 개발 모드 시작
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d webui

# 로그 확인
docker-compose -f docker-compose.yml -f docker-compose.dev.yml logs -f webui
```

### FastAPI BFF 개발 규칙

**디렉토리 구조**:
```
backend/
├── app/
│   ├── main.py         # FastAPI 앱
│   ├── routes/         # API 엔드포인트 (Chat, News, Observability)
│   ├── services/       # 비즈니스 로직 (LiteLLM, Langfuse)
│   ├── middleware/     # RBAC 등
│   └── config.py       # 설정 관리
├── requirements.txt
└── Dockerfile
```

**포트**: `8000` (프록시 및 BFF API)

**PYTHONPATH**: 자동 설정됨 (Docker WORKDIR=/app)

### 체크리스트: 새 백엔드 서비스 추가 시

webui/backend 수정 시:
- [ ] PYTHONPATH 설정 확인 (스크립트 또는 Dockerfile)
- [ ] `backend/` 디렉토리에서 상대 import 사용 (`from open_webui.xxx import yyy`)
- [ ] 개발 환경 테스트: `docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d webui`
- [ ] 로그 확인: `ModuleNotFoundError` 발생 여부

backend/ (FastAPI BFF) 수정 시:
- [ ] `app/` 디렉토리 구조 유지
- [ ] Type hints 및 Docstring 작성
- [ ] 서비스 레이어 패턴 준수 (Singleton)
- [ ] 에러 핸들링 및 타임아웃 설정 (30초)

### 가드레일: 절대 하지 말아야 할 것

1. **webui/backend에서 절대 경로 import 금지**:
   - ❌ `from /app/backend/open_webui import xxx`
   - ✅ `from open_webui import xxx` (PYTHONPATH 기준 상대 경로)

2. **PYTHONPATH 없이 uvicorn 실행 금지**:
   - ❌ `uvicorn open_webui.main:app`
   - ✅ `PYTHONPATH=. uvicorn open_webui.main:app`

3. **dev-start.sh 수정 시 PYTHONPATH 유지**:
   - 항상 `PYTHONPATH=.`를 uvicorn 명령 앞에 추가

4. **두 백엔드 혼동 금지**:
   - `webui/backend`: Open-WebUI 내장, port 8080 (컨테이너 내부)
   - `backend/`: FastAPI BFF, port 8000

## 참고 자료

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [HTTPX Documentation](https://www.python-httpx.org/)
- [PEP 8 Style Guide](https://pep8.org/)
