---
alwaysApply: false
---
# Planning Strategies

Eight planning strategies for coding tasks. Invest 15-20 minutes before coding to save hours of debugging.

## Strategy 1: Bug Reproduction

Before fixing, reproduce and document the bug.

```markdown
## Bug Reproduction Steps

1. Navigate to http://localhost:3001/admin/monitoring
2. Click "Summary" tab
3. Observe: "Failed to fetch" error in console

## Root Cause
- API timeout not set
- No error handling

## Fix
- Add 30s timeout
- Add try/catch with user-friendly message
```

Record in: `.cursor/learnings/bug-fixes.md`

## Strategy 2: Best Practices Research

Search web for similar problem solutions.

**Sources**:
- Official docs (SvelteKit, FastAPI, Tailwind)
- GitHub issues
- Stack Overflow

**Record findings**:
```markdown
## Date: SvelteKit Error Handling

**Source**: https://kit.svelte.dev/docs/errors
**Pattern**: throw error() in load()
**Benefit**: Automatic error page rendering
**Apply**: All load() functions
```

## Strategy 3: Codebase Investigation

Check existing patterns before implementing.

```bash
# Find similar patterns
grep -r "IntersectionObserver" webui/src/

# Find existing service patterns
ls backend/app/services/

# Query UI patterns
jq '.buttonPatterns[] | select(.type == "tab")' webui/.skills/ui-patterns.json
```

Reuse existing patterns for consistency.

## Strategy 4: Library Source Investigation

When docs are insufficient, check source code.

```bash
# Find GitHub repo examples
# - examples/ directory
# - tests/ directory
# - README.md

# Document findings
echo "## Date: paneforge usage
**Source**: github.com/huntabyte/paneforge
**Usage**: <PaneGroup direction=\"horizontal\">
**Note**: direction required, defaultSize sums to 100
" >> .cursor/learnings/api-patterns.md
```

## Strategy 5: Git History Investigation

Check previous solutions.

```bash
# Search commits by keyword
git log --all --grep="monitoring" --oneline

# View specific commit
git show <commit-hash>

# File history
git log -p -- backend/app/routes/chat.py
```

## Strategy 6: Prototyping

For complex features, prototype small first.

```python
# /tmp/prototype/test.py
import httpx
import asyncio

async def test():
    async with httpx.AsyncClient(timeout=30.0) as client:
        response = await client.get("http://localhost:8000/test")
        print(response.json())

asyncio.run(test())
```

After validation, integrate into main code.

## Strategy 7: Options Comparison

Compare 2-3 approaches before choosing.

| Option | Pros | Cons |
|--------|------|------|
| HTTPException | FastAPI standard, OpenAPI docs | Limited customization |
| Custom Exception | Flexible response | More code |
| Direct Response | Full control | No OpenAPI |

**Choose**: Option 1 (HTTPException)
**Reason**: Standard pattern, auto documentation

Record choice in commit message.

## Strategy 8: Style Review

Before committing, check consistency.

**UI**:
```bash
# Check color palette
cat webui/.skills/ui-summary.json | jq '.colors'

# Check existing patterns
cat webui/.skills/ui-summary.json | jq '.patterns'
```

**Backend**:
- [ ] Async methods
- [ ] Type hints
- [ ] Timeout set
- [ ] Error handling

## Strategy Selection by Complexity

### Simple (5-10 min)
- Strategy 3: Codebase
- Strategy 8: Style

### Medium (10-15 min)
- Strategy 2: Best practices
- Strategy 3: Codebase
- Strategy 7: Options
- Strategy 8: Style

### Complex (15-20 min)
- Strategy 1: Bug reproduction
- Strategy 2: Best practices
- Strategy 3: Codebase
- Strategy 5: Git history
- Strategy 6: Prototype
- Strategy 7: Options
- Strategy 8: Style

---

**Last Updated**: 2025-11-28
